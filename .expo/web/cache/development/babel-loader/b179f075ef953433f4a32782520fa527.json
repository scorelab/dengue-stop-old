{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nvar _jsxFileName = \"/Users/satya/Workspace/Projects/react-native-tab-view/src/ScrollPager.tsx\";\nimport * as React from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Keyboard from \"react-native-web/dist/exports/Keyboard\";\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport Animated from 'react-native-reanimated';\nvar event = Animated.event,\n    divide = Animated.divide,\n    Value = Animated.Value;\n\nvar ScrollPager = function (_React$Component) {\n  _inherits(ScrollPager, _React$Component);\n\n  function ScrollPager() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, ScrollPager);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ScrollPager)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.initialOffset = {\n      x: _this.props.navigationState.index * _this.props.layout.width,\n      y: 0\n    };\n    _this.interactionHandle = null;\n    _this.scrollViewRef = React.createRef();\n\n    _this.jumpTo = function (key) {\n      var _this$props = _this.props,\n          navigationState = _this$props.navigationState,\n          keyboardDismissMode = _this$props.keyboardDismissMode,\n          onIndexChange = _this$props.onIndexChange;\n      var index = navigationState.routes.findIndex(function (route) {\n        return route.key === key;\n      });\n\n      if (navigationState.index === index) {\n        _this.scrollTo(index * _this.props.layout.width);\n      } else {\n        onIndexChange(index);\n\n        if (keyboardDismissMode === 'auto') {\n          Keyboard.dismiss();\n        }\n      }\n    };\n\n    _this.scrollTo = function (x) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (_this.scrollViewRef.current) {\n        _this.scrollViewRef.current.getNode().scrollTo({\n          x: x,\n          animated: animated\n        });\n      }\n    };\n\n    _this.enterListeners = [];\n\n    _this.addListener = function (type, listener) {\n      switch (type) {\n        case 'enter':\n          _this.enterListeners.push(listener);\n\n          break;\n      }\n    };\n\n    _this.removeListener = function (type, listener) {\n      switch (type) {\n        case 'enter':\n          {\n            var index = _this.enterListeners.indexOf(listener);\n\n            if (index > -1) {\n              _this.enterListeners.splice(index, 1);\n            }\n\n            break;\n          }\n      }\n    };\n\n    _this.position = new Animated.Value(_this.props.navigationState.index * _this.props.layout.width);\n    _this.onScroll = event([{\n      nativeEvent: {\n        contentOffset: {\n          x: _this.position\n        }\n      }\n    }]);\n    _this.layoutWidthNode = new Value(_this.props.layout.width);\n    _this.relativePosition = divide(_this.position, _this.layoutWidthNode);\n    return _this;\n  }\n\n  _createClass(ScrollPager, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.layout.width) {\n        this.scrollTo(this.props.navigationState.index * this.props.layout.width, false);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var offset = this.props.navigationState.index * this.props.layout.width;\n\n      if (prevProps.navigationState.routes.length !== this.props.navigationState.routes.length || prevProps.layout.width !== this.props.layout.width) {\n        this.scrollTo(offset, false);\n      } else if (prevProps.navigationState.index !== this.props.navigationState.index) {\n        this.scrollTo(offset);\n      }\n\n      if (prevProps.layout.width !== this.props.layout.width) {\n        this.layoutWidthNode.setValue(this.props.layout.width);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.interactionHandle !== null) {\n        InteractionManager.clearInteractionHandle(this.interactionHandle);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props2 = this.props,\n          children = _this$props2.children,\n          layout = _this$props2.layout,\n          onSwipeStart = _this$props2.onSwipeStart,\n          onSwipeEnd = _this$props2.onSwipeEnd,\n          overscroll = _this$props2.overscroll,\n          navigationState = _this$props2.navigationState;\n\n      var handleSwipeStart = function handleSwipeStart() {\n        onSwipeStart == null ? void 0 : onSwipeStart();\n        _this2.interactionHandle = InteractionManager.createInteractionHandle();\n      };\n\n      var handleSwipeEnd = function handleSwipeEnd() {\n        onSwipeEnd == null ? void 0 : onSwipeEnd();\n\n        if (_this2.interactionHandle !== null) {\n          InteractionManager.clearInteractionHandle(_this2.interactionHandle);\n        }\n      };\n\n      return children({\n        position: this.relativePosition,\n        addListener: this.addListener,\n        removeListener: this.removeListener,\n        jumpTo: this.jumpTo,\n        render: function render(children) {\n          return React.createElement(Animated.ScrollView, {\n            pagingEnabled: true,\n            directionalLockEnabled: true,\n            keyboardDismissMode: \"on-drag\",\n            keyboardShouldPersistTaps: \"always\",\n            overScrollMode: \"never\",\n            scrollToOverflowEnabled: true,\n            scrollEnabled: _this2.props.swipeEnabled,\n            automaticallyAdjustContentInsets: false,\n            bounces: overscroll,\n            scrollsToTop: false,\n            showsHorizontalScrollIndicator: false,\n            scrollEventThrottle: 1,\n            onScroll: _this2.onScroll,\n            onScrollBeginDrag: handleSwipeStart,\n            onScrollEndDrag: handleSwipeEnd,\n            onMomentumScrollEnd: _this2.onScroll,\n            contentOffset: _this2.initialOffset,\n            style: styles.container,\n            contentContainerStyle: layout.width ? {\n              flexDirection: 'row',\n              width: layout.width * navigationState.routes.length,\n              flex: 1\n            } : null,\n            ref: _this2.scrollViewRef,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 160\n            }\n          }, children);\n        }\n      });\n    }\n  }]);\n\n  return ScrollPager;\n}(React.Component);\n\nScrollPager.defaultProps = {\n  bounces: true\n};\nexport { ScrollPager as default };\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  }\n});","map":{"version":3,"sources":["ScrollPager.tsx"],"names":["event","divide","Value","Animated","ScrollPager","React","Component","defaultProps","bounces","prevProps","offset","InteractionManager","initialOffset","x","y","interactionHandle","scrollViewRef","jumpTo","navigationState","keyboardDismissMode","onIndexChange","index","route","Keyboard","scrollTo","animated","enterListeners","addListener","removeListener","position","onScroll","nativeEvent","contentOffset","layoutWidthNode","relativePosition","children","layout","onSwipeStart","onSwipeEnd","overscroll","handleSwipeStart","handleSwipeEnd","render","styles","flexDirection","width","flex","StyleSheet","container"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { StyleSheet, Keyboard, InteractionManager } from 'react-native';\nimport Animated from 'react-native-reanimated';\nimport { Props } from './Pager';\nimport { Route, Listener } from './types';\n\nconst { event, divide, Value } = Animated;\n\ntype State = {\n  initialOffset: { x: number; y: number };\n};\n\nexport default class ScrollPager<T extends Route> extends React.Component<\n  Props<T> & { overscroll?: boolean },\n  State\n> {\n  static defaultProps = {\n    bounces: true,\n  };\n\n  componentDidMount() {\n    if (this.props.layout.width) {\n      this.scrollTo(\n        this.props.navigationState.index * this.props.layout.width,\n        false\n      );\n    }\n  }\n\n  componentDidUpdate(prevProps: Props<T>) {\n    const offset = this.props.navigationState.index * this.props.layout.width;\n\n    if (\n      prevProps.navigationState.routes.length !==\n        this.props.navigationState.routes.length ||\n      prevProps.layout.width !== this.props.layout.width\n    ) {\n      this.scrollTo(offset, false);\n    } else if (\n      prevProps.navigationState.index !== this.props.navigationState.index\n    ) {\n      this.scrollTo(offset);\n    }\n\n    if (prevProps.layout.width !== this.props.layout.width) {\n      this.layoutWidthNode.setValue(this.props.layout.width);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.interactionHandle !== null) {\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\n    }\n  }\n\n  private initialOffset = {\n    x: this.props.navigationState.index * this.props.layout.width,\n    y: 0,\n  };\n\n  // InteractionHandle to handle tasks around animations\n  private interactionHandle: number | null = null;\n\n  private scrollViewRef = React.createRef<Animated.ScrollView>();\n\n  private jumpTo = (key: string) => {\n    const { navigationState, keyboardDismissMode, onIndexChange } = this.props;\n\n    const index = navigationState.routes.findIndex(route => route.key === key);\n\n    if (navigationState.index === index) {\n      this.scrollTo(index * this.props.layout.width);\n    } else {\n      onIndexChange(index);\n      if (keyboardDismissMode === 'auto') {\n        Keyboard.dismiss();\n      }\n    }\n  };\n\n  private scrollTo = (x: number, animated = true) => {\n    if (this.scrollViewRef.current) {\n      this.scrollViewRef.current.getNode().scrollTo({\n        x,\n        animated: animated,\n      });\n    }\n  };\n\n  private enterListeners: Listener[] = [];\n\n  private addListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter':\n        this.enterListeners.push(listener);\n        break;\n    }\n  };\n\n  private removeListener = (type: 'enter', listener: Listener) => {\n    switch (type) {\n      case 'enter': {\n        const index = this.enterListeners.indexOf(listener);\n\n        if (index > -1) {\n          this.enterListeners.splice(index, 1);\n        }\n\n        break;\n      }\n    }\n  };\n\n  private position = new Animated.Value(\n    this.props.navigationState.index * this.props.layout.width\n  );\n\n  private onScroll = event([\n    {\n      nativeEvent: {\n        contentOffset: {\n          x: this.position,\n        },\n      },\n    },\n  ]);\n\n  private layoutWidthNode = new Value(this.props.layout.width);\n\n  private relativePosition = divide(this.position, this.layoutWidthNode);\n\n  render() {\n    const {\n      children,\n      layout,\n      onSwipeStart,\n      onSwipeEnd,\n      overscroll,\n      navigationState,\n    } = this.props;\n\n    const handleSwipeStart = () => {\n      onSwipeStart?.();\n      this.interactionHandle = InteractionManager.createInteractionHandle();\n    };\n\n    const handleSwipeEnd = () => {\n      onSwipeEnd?.();\n      if (this.interactionHandle !== null) {\n        InteractionManager.clearInteractionHandle(this.interactionHandle);\n      }\n    };\n\n    return children({\n      position: this.relativePosition,\n      addListener: this.addListener,\n      removeListener: this.removeListener,\n      jumpTo: this.jumpTo,\n      render: children => (\n        <Animated.ScrollView\n          pagingEnabled\n          directionalLockEnabled\n          keyboardDismissMode=\"on-drag\"\n          keyboardShouldPersistTaps=\"always\"\n          overScrollMode=\"never\"\n          scrollToOverflowEnabled\n          scrollEnabled={this.props.swipeEnabled}\n          automaticallyAdjustContentInsets={false}\n          bounces={overscroll}\n          scrollsToTop={false}\n          showsHorizontalScrollIndicator={false}\n          scrollEventThrottle={1}\n          onScroll={this.onScroll}\n          onScrollBeginDrag={handleSwipeStart}\n          onScrollEndDrag={handleSwipeEnd}\n          onMomentumScrollEnd={this.onScroll}\n          contentOffset={this.initialOffset}\n          style={styles.container}\n          contentContainerStyle={\n            layout.width\n              ? {\n                  flexDirection: 'row',\n                  width: layout.width * navigationState.routes.length,\n                  flex: 1,\n                }\n              : null\n          }\n          ref={this.scrollViewRef}\n        >\n          {children}\n        </Animated.ScrollView>\n      ),\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n});\n"]},"metadata":{},"sourceType":"module"}