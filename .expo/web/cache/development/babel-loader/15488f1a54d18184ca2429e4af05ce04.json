{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _toArray from \"@babel/runtime/helpers/toArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport pathToRegexp from 'path-to-regexp';\n\nvar compilePathToRegex = function compilePathToRegex(path) {\n  var keys = [];\n  var re = pathToRegexp(path, keys);\n  return {\n    re: re,\n    keys: keys\n  };\n};\n\nexport var matchPath = function matchPath(path, url) {\n  var _url$split = url.split('?'),\n      _url$split2 = _slicedToArray(_url$split, 1),\n      urlCleaned = _url$split2[0];\n\n  var urlToMatch = !urlCleaned.endsWith('/') ? urlCleaned + \"/\" : urlCleaned;\n\n  var _compilePathToRegex = compilePathToRegex(path),\n      re = _compilePathToRegex.re,\n      keys = _compilePathToRegex.keys;\n\n  var match = re.exec(urlToMatch);\n\n  if (!match) {\n    return null;\n  }\n\n  var _match = _toArray(match),\n      compiledUrl = _match[0],\n      values = _match.slice(1);\n\n  if (urlToMatch !== compiledUrl) {\n    return null;\n  }\n\n  var params = keys.reduce(function (acc, key, index) {\n    return _extends({}, acc, _defineProperty({}, key.name, values[index]));\n  }, {});\n  return {\n    path: path,\n    params: params\n  };\n};\n\nvar pathParser = function pathParser(url) {\n  var possibleMatchingpaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return possibleMatchingpaths.map(function (path) {\n    return matchPath(path, url);\n  }).find(function (obj) {\n    return obj;\n  });\n};\n\nexport default pathParser;","map":{"version":3,"sources":["C:/Users/Thivagar/Documents/GSOC Work/dengue-stop/node_modules/react-native-router-flux/src/pathParser.js"],"names":["pathToRegexp","compilePathToRegex","path","keys","re","matchPath","url","split","urlCleaned","urlToMatch","endsWith","match","exec","compiledUrl","values","params","reduce","acc","key","index","name","pathParser","possibleMatchingpaths","map","find","obj"],"mappings":";;;;AAAA,OAAOA,YAAP,MAAyB,gBAAzB;;AAgCA,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,CAACC,IAAD,EAAU;AACnC,MAAMC,IAAI,GAAG,EAAb;AACA,MAAMC,EAAE,GAAGJ,YAAY,CAACE,IAAD,EAAOC,IAAP,CAAvB;AAGA,SAAO;AAAEC,IAAAA,EAAE,EAAFA,EAAF;AAAMD,IAAAA,IAAI,EAAJA;AAAN,GAAP;AACD,CAND;;AAkCA,OAAO,IAAME,SAAS,GAAG,SAAZA,SAAY,CAACH,IAAD,EAAOI,GAAP,EAAe;AAAA,mBAGjBA,GAAG,CAACC,KAAJ,CAAU,GAAV,CAHiB;AAAA;AAAA,MAG/BC,UAH+B;;AAMtC,MAAMC,UAAU,GAAG,CAACD,UAAU,CAACE,QAAX,CAAoB,GAApB,CAAD,GAA+BF,UAA/B,SAA+CA,UAAlE;;AANsC,4BASjBP,kBAAkB,CAACC,IAAD,CATD;AAAA,MAS9BE,EAT8B,uBAS9BA,EAT8B;AAAA,MAS1BD,IAT0B,uBAS1BA,IAT0B;;AAYtC,MAAMQ,KAAK,GAAGP,EAAE,CAACQ,IAAH,CAAQH,UAAR,CAAd;;AAGA,MAAI,CAACE,KAAL,EAAY;AACV,WAAO,IAAP;AACD;;AAjBqC,wBAqBLA,KArBK;AAAA,MAqB/BE,WArB+B;AAAA,MAqBfC,MArBe;;AAyBtC,MAAIL,UAAU,KAAKI,WAAnB,EAAgC;AAC9B,WAAO,IAAP;AACD;;AAED,MAAME,MAAM,GAAGZ,IAAI,CAACa,MAAL,CAAY,UAACC,GAAD,EAAMC,GAAN,EAAWC,KAAX;AAAA,WAAqB,SAAc,EAAd,EAAkBF,GAAlB,sBAA0BC,GAAG,CAACE,IAA9B,EAAqCN,MAAM,CAACK,KAAD,CAA3C,EAArB;AAAA,GAAZ,EAAwF,EAAxF,CAAf;AAEA,SAAO;AAAEjB,IAAAA,IAAI,EAAJA,IAAF;AAAQa,IAAAA,MAAM,EAANA;AAAR,GAAP;AACD,CAhCM;;AA4CP,IAAMM,UAAU,GAAG,SAAbA,UAAa,CAACf,GAAD;AAAA,MAAMgB,qBAAN,uEAA8B,EAA9B;AAAA,SAAqCA,qBAAqB,CAACC,GAAtB,CAA0B,UAAArB,IAAI;AAAA,WAAIG,SAAS,CAACH,IAAD,EAAOI,GAAP,CAAb;AAAA,GAA9B,EAAwDkB,IAAxD,CAA6D,UAAAC,GAAG;AAAA,WAAIA,GAAJ;AAAA,GAAhE,CAArC;AAAA,CAAnB;;AAEA,eAAeJ,UAAf","sourcesContent":["import pathToRegexp from 'path-to-regexp';\n\n/**\n *\n * This set of functions are used to match a url with a uri path.\n * This functionality is based on the internals of React-Router's matchPath.\n * - https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/matchPath.md\n *\n */\n\n/**\n * This function accepts a uri path and returns a regex to match that path\n * against a url and an array of the keys extracted from that uri path\n *\n * @param {String} path - a uri path in standard template (https://tools.ietf.org/html/rfc6570)\n *\n * Sample Input: \"/user/:id/\"\n *\n * Sample Output:\n * {\n *     re: /^\\/user\\/([^\\/]+?)\\/(?:\\/(?=$))?/i,\n *     keys: [\n *         name: \"id\"\n *         delimiter: \"/\"\n *         optional: false\n *         partial: false\n *         path: \"[^\\/]+?\"\n *         prefix: \"/\"\n *         repeat: false,\n *     ]\n * }\n */\nconst compilePathToRegex = (path) => {\n  const keys = [];\n  const re = pathToRegexp(path, keys);\n  // Returns the regex path to match a uri path to an actual url\n  // and the keys that can be used to pull values from the url.\n  return { re, keys };\n};\n\n/**\n * This function accepts a uri path and an actual url. It determines whether\n * or not they match one another. If they do not match, the funtion returns null.\n * If they do match, then the function returns the path and the params parsed\n * from the url.\n *\n * @param {String} path - a uri path in standard template (https://tools.ietf.org/html/rfc6570)\n * @param {String} url - a url that may or may not match the given path\n *\n * Case 1 - path Does Not Match Url:\n *   Sample Input: (path: \"/edit/organization/(:id)\", url: \"/user/300002/\")\n *\n *   Sample Output: null\n *\n * Case 2 - path Does Match Url:\n *   Sample Input: (path: \"/user/:id/\", url: \"/user/300002/\")\n *\n *   Sample Output:\n *   {\n *       path: \"/user/:id/\",\n *       params: {\n *           id: \"300002\",\n *       }\n *   }\n *\n */\nexport const matchPath = (path, url) => {\n  // Remove possible query fragments, which are not supported by iOS and some\n  // versions of Anroid.\n  const [urlCleaned] = url.split('?');\n\n  // Append trailing slash for compatibility with pathToRegexp\n  const urlToMatch = !urlCleaned.endsWith('/') ? `${urlCleaned}/` : urlCleaned;\n\n  // Return the regex and the keys that can be parsed from a uri path.\n  const { re, keys } = compilePathToRegex(path);\n\n  // Check if the given url matches the uri path.\n  const match = re.exec(urlToMatch);\n\n  // If there is no match, then return null.\n  if (!match) {\n    return null;\n  }\n\n  // Destructure to return the compiled url (aka the reconstructed url based\n  // on the regex and the url parameters.\n  const [compiledUrl, ...values] = match;\n\n  // If there is an inexact match (aka the compiled path does not match the\n  // given url, then return null)\n  if (urlToMatch !== compiledUrl) {\n    return null;\n  }\n\n  const params = keys.reduce((acc, key, index) => Object.assign({}, acc, { [key.name]: values[index] }), {});\n\n  return { path, params };\n};\n\n/**\n * This function accepts an array of uri paths and a url. If there are no paths\n * in the array that match the given url, then the function will return null.\n * If there is at least one matching uri path, it will return the first\n * matching path and the parsed url parameters (the output from matchPath()).\n *\n * @param {Array} possibleMatchingpaths - an array of uri paths in standard template (https://tools.ietf.org/html/rfc6570)\n * @param {String} url - a url that may or may not match a given path\n *\n */\nconst pathParser = (url, possibleMatchingpaths = []) => possibleMatchingpaths.map(path => matchPath(path, url)).find(obj => obj);\n\nexport default pathParser;\n"]},"metadata":{},"sourceType":"module"}