{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport ReanimatedModule from \"../ReanimatedModule\";\nvar UPDATED_NODES = [];\nvar loopID = 1;\nvar propUpdatesEnqueued = null;\n\nfunction sanitizeConfig(config) {\n  for (var key in config) {\n    var value = config[key];\n\n    if (value instanceof AnimatedNode) {\n      config[key] = value.__nodeID;\n    }\n  }\n\n  return config;\n}\n\nfunction runPropUpdates() {\n  var visitedNodes = new Set();\n\n  var findAndUpdateNodes = function findAndUpdateNodes(node) {\n    if (!node) {\n      console.warn('findAndUpdateNodes was passed a nullish node');\n      return;\n    }\n\n    if (visitedNodes.has(node)) {\n      return;\n    } else {\n      visitedNodes.add(node);\n    }\n\n    if (typeof node.update === 'function') {\n      node.update();\n    } else {\n      var nodes = node.__getChildren();\n\n      if (nodes) {\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          findAndUpdateNodes(nodes[i]);\n        }\n      }\n    }\n  };\n\n  for (var i = 0; i < UPDATED_NODES.length; i++) {\n    var node = UPDATED_NODES[i];\n    findAndUpdateNodes(node);\n  }\n\n  UPDATED_NODES.length = 0;\n  propUpdatesEnqueued = null;\n  loopID += 1;\n}\n\nvar nodeCount = 0;\n\nvar AnimatedNode = function () {\n  function AnimatedNode(nodeConfig, inputNodes) {\n    _classCallCheck(this, AnimatedNode);\n\n    this.__lastLoopID = 0;\n    this.__memoizedValue = null;\n    this.__children = [];\n    this.__nodeID = ++nodeCount;\n    this.__nodeConfig = sanitizeConfig(nodeConfig);\n    this.__initialized = false;\n    this.__inputNodes = inputNodes && inputNodes.filter(function (node) {\n      return node instanceof AnimatedNode;\n    });\n  }\n\n  _createClass(AnimatedNode, [{\n    key: \"__attach\",\n    value: function __attach() {\n      this.__nativeInitialize();\n\n      var nodes = this.__inputNodes;\n\n      if (nodes) {\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          nodes[i].__addChild(this);\n        }\n      }\n    }\n  }, {\n    key: \"__detach\",\n    value: function __detach() {\n      var nodes = this.__inputNodes;\n\n      if (nodes) {\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          nodes[i].__removeChild(this);\n        }\n      }\n\n      this.__nativeTearDown();\n    }\n  }, {\n    key: \"__getValue\",\n    value: function __getValue() {\n      if (this.__lastLoopID < loopID) {\n        this.__lastLoopID = loopID;\n        return this.__memoizedValue = this.__onEvaluate();\n      }\n\n      return this.__memoizedValue;\n    }\n  }, {\n    key: \"__forceUpdateCache\",\n    value: function __forceUpdateCache(newValue) {\n      this.__memoizedValue = newValue;\n\n      this.__markUpdated();\n    }\n  }, {\n    key: \"__dangerouslyRescheduleEvaluate\",\n    value: function __dangerouslyRescheduleEvaluate() {\n      this.__lastLoopID = 0;\n\n      this.__markUpdated();\n    }\n  }, {\n    key: \"__markUpdated\",\n    value: function __markUpdated() {\n      UPDATED_NODES.push(this);\n\n      if (!propUpdatesEnqueued) {\n        propUpdatesEnqueued = setImmediate(runPropUpdates);\n      }\n    }\n  }, {\n    key: \"__nativeInitialize\",\n    value: function __nativeInitialize() {\n      if (!this.__initialized) {\n        ReanimatedModule.createNode(this.__nodeID, _objectSpread({}, this.__nodeConfig));\n        this.__initialized = true;\n      }\n    }\n  }, {\n    key: \"__nativeTearDown\",\n    value: function __nativeTearDown() {\n      if (this.__initialized) {\n        ReanimatedModule.dropNode(this.__nodeID);\n        this.__initialized = false;\n      }\n    }\n  }, {\n    key: \"isNativelyInitialized\",\n    value: function isNativelyInitialized() {\n      return this.__initialized;\n    }\n  }, {\n    key: \"__onEvaluate\",\n    value: function __onEvaluate() {\n      throw new Error('Missing implementation of onEvaluate');\n    }\n  }, {\n    key: \"__getProps\",\n    value: function __getProps() {\n      return this.__getValue();\n    }\n  }, {\n    key: \"__getChildren\",\n    value: function __getChildren() {\n      return this.__children;\n    }\n  }, {\n    key: \"__addChild\",\n    value: function __addChild(child) {\n      if (this.__children.length === 0) {\n        this.__attach();\n      }\n\n      this.__children.push(child);\n\n      child.__nativeInitialize();\n\n      if (ReanimatedModule.connectNodes) {\n        ReanimatedModule.connectNodes(this.__nodeID, child.__nodeID);\n      } else {\n        this.__dangerouslyRescheduleEvaluate();\n      }\n    }\n  }, {\n    key: \"__removeChild\",\n    value: function __removeChild(child) {\n      var index = this.__children.indexOf(child);\n\n      if (index === -1) {\n        console.warn(\"Trying to remove a child that doesn't exist\");\n        return;\n      }\n\n      ReanimatedModule.disconnectNodes(this.__nodeID, child.__nodeID);\n\n      this.__children.splice(index, 1);\n\n      if (this.__children.length === 0) {\n        this.__detach();\n      }\n    }\n  }, {\n    key: \"_connectAnimatedView\",\n    value: function _connectAnimatedView(nativeViewTag) {\n      if (ReanimatedModule.connectNodeToView) {\n        ReanimatedModule.connectNodeToView(this.__nodeID, nativeViewTag);\n      } else {\n        this.__dangerouslyRescheduleEvaluate();\n      }\n    }\n  }, {\n    key: \"_disconnectAnimatedView\",\n    value: function _disconnectAnimatedView(nativeViewTag) {\n      ReanimatedModule.disconnectNodeFromView(this.__nodeID, nativeViewTag);\n    }\n  }]);\n\n  return AnimatedNode;\n}();\n\nexport { AnimatedNode as default };","map":{"version":3,"sources":["C:/Users/Thivagar/Documents/GSOC Work/dengue-stop/node_modules/react-native-reanimated/src/core/AnimatedNode.js"],"names":["ReanimatedModule","UPDATED_NODES","loopID","propUpdatesEnqueued","sanitizeConfig","config","key","value","AnimatedNode","__nodeID","runPropUpdates","visitedNodes","Set","findAndUpdateNodes","node","console","warn","has","add","update","nodes","__getChildren","i","l","length","nodeCount","nodeConfig","inputNodes","__lastLoopID","__memoizedValue","__children","__nodeConfig","__initialized","__inputNodes","filter","__nativeInitialize","__addChild","__removeChild","__nativeTearDown","__onEvaluate","newValue","__markUpdated","push","setImmediate","createNode","dropNode","Error","__getValue","child","__attach","connectNodes","__dangerouslyRescheduleEvaluate","index","indexOf","disconnectNodes","splice","__detach","nativeViewTag","connectNodeToView","disconnectNodeFromView"],"mappings":"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","sourcesContent":["import ReanimatedModule from '../ReanimatedModule';\n\nconst UPDATED_NODES = [];\n\nlet loopID = 1;\nlet propUpdatesEnqueued = null;\n\nfunction sanitizeConfig(config) {\n  for (const key in config) {\n    const value = config[key];\n    if (value instanceof AnimatedNode) {\n      config[key] = value.__nodeID;\n    }\n  }\n  return config;\n}\n\nfunction runPropUpdates() {\n  const visitedNodes = new Set();\n  const findAndUpdateNodes = node => {\n    if (!node) {\n      console.warn('findAndUpdateNodes was passed a nullish node');\n      return;\n    }\n\n    if (visitedNodes.has(node)) {\n      return;\n    } else {\n      visitedNodes.add(node);\n    }\n    if (typeof node.update === 'function') {\n      node.update();\n    } else {\n      const nodes = node.__getChildren();\n      if (nodes) {\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          findAndUpdateNodes(nodes[i]);\n        }\n      }\n    }\n  };\n  for (let i = 0; i < UPDATED_NODES.length; i++) {\n    const node = UPDATED_NODES[i];\n    findAndUpdateNodes(node);\n  }\n  UPDATED_NODES.length = 0; // clear array\n  propUpdatesEnqueued = null;\n  loopID += 1;\n}\n\nlet nodeCount = 0;\n\nexport default class AnimatedNode {\n  constructor(nodeConfig, inputNodes) {\n    this.__nodeID = ++nodeCount;\n    this.__nodeConfig = sanitizeConfig(nodeConfig);\n    this.__initialized = false;\n    this.__inputNodes =\n      inputNodes && inputNodes.filter(node => node instanceof AnimatedNode);\n  }\n\n  __attach() {\n    this.__nativeInitialize();\n\n    const nodes = this.__inputNodes;\n\n    if (nodes) {\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].__addChild(this);\n      }\n    }\n  }\n\n  __detach() {\n    const nodes = this.__inputNodes;\n\n    if (nodes) {\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        nodes[i].__removeChild(this);\n      }\n    }\n\n    this.__nativeTearDown();\n  }\n\n  __lastLoopID = 0;\n  __memoizedValue = null;\n\n  __children = [];\n\n  __getValue() {\n    if (this.__lastLoopID < loopID) {\n      this.__lastLoopID = loopID;\n      return (this.__memoizedValue = this.__onEvaluate());\n    }\n    return this.__memoizedValue;\n  }\n\n  __forceUpdateCache(newValue) {\n    this.__memoizedValue = newValue;\n    this.__markUpdated();\n  }\n\n  __dangerouslyRescheduleEvaluate() {\n    this.__lastLoopID = 0;\n    this.__markUpdated();\n  }\n\n  __markUpdated() {\n    UPDATED_NODES.push(this);\n    if (!propUpdatesEnqueued) {\n      propUpdatesEnqueued = setImmediate(runPropUpdates);\n    }\n  }\n\n  __nativeInitialize() {\n    if (!this.__initialized) {\n      ReanimatedModule.createNode(this.__nodeID, { ...this.__nodeConfig });\n      this.__initialized = true;\n    }\n  }\n\n  __nativeTearDown() {\n    if (this.__initialized) {\n      ReanimatedModule.dropNode(this.__nodeID);\n      this.__initialized = false;\n    }\n  }\n\n  isNativelyInitialized() {\n    return this.__initialized;\n  }\n\n  __onEvaluate() {\n    throw new Error('Missing implementation of onEvaluate');\n  }\n\n  __getProps() {\n    return this.__getValue();\n  }\n\n  __getChildren() {\n    return this.__children;\n  }\n\n  __addChild(child) {\n    if (this.__children.length === 0) {\n      this.__attach();\n    }\n    this.__children.push(child);\n    child.__nativeInitialize();\n\n    if (ReanimatedModule.connectNodes) {\n      ReanimatedModule.connectNodes(this.__nodeID, child.__nodeID);\n    } else {\n      this.__dangerouslyRescheduleEvaluate();\n    }\n  }\n\n  __removeChild(child) {\n    const index = this.__children.indexOf(child);\n    if (index === -1) {\n      console.warn(\"Trying to remove a child that doesn't exist\");\n      return;\n    }\n    ReanimatedModule.disconnectNodes(this.__nodeID, child.__nodeID);\n\n    this.__children.splice(index, 1);\n    if (this.__children.length === 0) {\n      this.__detach();\n    }\n  }\n\n  _connectAnimatedView(nativeViewTag) {\n    if (ReanimatedModule.connectNodeToView) {\n      ReanimatedModule.connectNodeToView(this.__nodeID, nativeViewTag);\n    } else {\n      this.__dangerouslyRescheduleEvaluate();\n    }\n  }\n\n  _disconnectAnimatedView(nativeViewTag) {\n    ReanimatedModule.disconnectNodeFromView(this.__nodeID, nativeViewTag);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}