{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport React from 'react';\nimport { createAnimatedAlways } from \"./AnimatedAlways\";\nimport AnimatedNode from \"./AnimatedNode\";\n\nvar Code = function (_React$Component) {\n  _inherits(Code, _React$Component);\n\n  function Code() {\n    _classCallCheck(this, Code);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Code).apply(this, arguments));\n  }\n\n  _createClass(Code, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          exec = _this$props.exec;\n      var nodeChildren = Code.resolveNode(children);\n      var nodeExec = Code.resolveNode(exec);\n      var cantResolveNode = nodeChildren === null && nodeExec === null;\n\n      if (cantResolveNode) {\n        var error = nodeChildren === null ? \"Got \\\"\" + typeof children + \"\\\" type passed to children\" : \"Got \\\"\" + typeof exec + \"\\\" type passed to exec\";\n        throw new Error(\"<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node. \" + error);\n      }\n\n      this.always = createAnimatedAlways(nodeExec || nodeChildren);\n\n      this.always.__attach();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.always.__detach();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return Code;\n}(React.Component);\n\nCode.resolveNode = function (maybeNode) {\n  if (typeof maybeNode === 'function') {\n    return Code.resolveNode(maybeNode());\n  }\n\n  if (maybeNode instanceof AnimatedNode) {\n    return maybeNode;\n  }\n\n  return null;\n};\n\nexport default Code;","map":{"version":3,"sources":["C:/Users/Thivagar/Documents/GSOC Work/dengue-stop/node_modules/react-native-reanimated/src/core/AnimatedCode.js"],"names":["React","createAnimatedAlways","AnimatedNode","Code","props","children","exec","nodeChildren","resolveNode","nodeExec","cantResolveNode","error","Error","always","__attach","__detach","Component","maybeNode"],"mappings":";;;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,oBAAT;AACA,OAAOC,YAAP;;IAEMC,I;;;;;;;;;;;wCAagB;AAAA,wBACS,KAAKC,KADd;AAAA,UACVC,QADU,eACVA,QADU;AAAA,UACAC,IADA,eACAA,IADA;AAElB,UAAMC,YAAY,GAAGJ,IAAI,CAACK,WAAL,CAAiBH,QAAjB,CAArB;AACA,UAAMI,QAAQ,GAAGN,IAAI,CAACK,WAAL,CAAiBF,IAAjB,CAAjB;AAEA,UAAMI,eAAe,GAAGH,YAAY,KAAK,IAAjB,IAAyBE,QAAQ,KAAK,IAA9D;;AAEA,UAAIC,eAAJ,EAAqB;AACnB,YAAMC,KAAK,GACTJ,YAAY,KAAK,IAAjB,cACY,OAAOF,QADnB,6CAEY,OAAOC,IAFnB,2BADF;AAKA,cAAM,IAAIM,KAAJ,6HACsHD,KADtH,CAAN;AAGD;;AAED,WAAKE,MAAL,GAAcZ,oBAAoB,CAACQ,QAAQ,IAAIF,YAAb,CAAlC;;AACA,WAAKM,MAAL,CAAYC,QAAZ;AACD;;;2CAEsB;AACrB,WAAKD,MAAL,CAAYE,QAAZ;AACD;;;6BAEQ;AACP,aAAO,IAAP;AACD;;;;EAzCgBf,KAAK,CAACgB,S;;AAAnBb,I,CACGK,W,GAAc,UAAAS,SAAS,EAAI;AAChC,MAAI,OAAOA,SAAP,KAAqB,UAAzB,EAAqC;AACnC,WAAOd,IAAI,CAACK,WAAL,CAAiBS,SAAS,EAA1B,CAAP;AACD;;AAED,MAAIA,SAAS,YAAYf,YAAzB,EAAuC;AACrC,WAAOe,SAAP;AACD;;AAED,SAAO,IAAP;AACD,C;;AAgCH,eAAed,IAAf","sourcesContent":["import React from 'react';\nimport { createAnimatedAlways } from './AnimatedAlways';\nimport AnimatedNode from './AnimatedNode';\n\nclass Code extends React.Component {\n  static resolveNode = maybeNode => {\n    if (typeof maybeNode === 'function') {\n      return Code.resolveNode(maybeNode());\n    }\n\n    if (maybeNode instanceof AnimatedNode) {\n      return maybeNode;\n    }\n\n    return null;\n  };\n\n  componentDidMount() {\n    const { children, exec } = this.props;\n    const nodeChildren = Code.resolveNode(children);\n    const nodeExec = Code.resolveNode(exec);\n\n    const cantResolveNode = nodeChildren === null && nodeExec === null;\n\n    if (cantResolveNode) {\n      const error =\n        nodeChildren === null\n          ? `Got \"${typeof children}\" type passed to children`\n          : `Got \"${typeof exec}\" type passed to exec`;\n\n      throw new Error(\n        `<Animated.Code /> expects the 'exec' prop or children to be an animated node or a function returning an animated node. ${error}`\n      );\n    }\n\n    this.always = createAnimatedAlways(nodeExec || nodeChildren);\n    this.always.__attach();\n  }\n\n  componentWillUnmount() {\n    this.always.__detach();\n  }\n\n  render() {\n    return null;\n  }\n}\nexport default Code;\n"]},"metadata":{},"sourceType":"module"}