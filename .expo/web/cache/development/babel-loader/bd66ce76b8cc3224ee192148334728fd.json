{"ast":null,"code":"'use strict';\n\nvar inherits = require('inherits'),\n    EventEmitter = require('events').EventEmitter;\n\nvar debug = function debug() {};\n\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:buffered-sender');\n}\n\nfunction BufferedSender(url, sender) {\n  debug(url);\n  EventEmitter.call(this);\n  this.sendBuffer = [];\n  this.sender = sender;\n  this.url = url;\n}\n\ninherits(BufferedSender, EventEmitter);\n\nBufferedSender.prototype.send = function (message) {\n  debug('send', message);\n  this.sendBuffer.push(message);\n\n  if (!this.sendStop) {\n    this.sendSchedule();\n  }\n};\n\nBufferedSender.prototype.sendScheduleWait = function () {\n  debug('sendScheduleWait');\n  var self = this;\n  var tref;\n\n  this.sendStop = function () {\n    debug('sendStop');\n    self.sendStop = null;\n    clearTimeout(tref);\n  };\n\n  tref = setTimeout(function () {\n    debug('timeout');\n    self.sendStop = null;\n    self.sendSchedule();\n  }, 25);\n};\n\nBufferedSender.prototype.sendSchedule = function () {\n  debug('sendSchedule', this.sendBuffer.length);\n  var self = this;\n\n  if (this.sendBuffer.length > 0) {\n    var payload = '[' + this.sendBuffer.join(',') + ']';\n    this.sendStop = this.sender(this.url, payload, function (err) {\n      self.sendStop = null;\n\n      if (err) {\n        debug('error', err);\n        self.emit('close', err.code || 1006, 'Sending error: ' + err);\n        self.close();\n      } else {\n        self.sendScheduleWait();\n      }\n    });\n    this.sendBuffer = [];\n  }\n};\n\nBufferedSender.prototype._cleanup = function () {\n  debug('_cleanup');\n  this.removeAllListeners();\n};\n\nBufferedSender.prototype.close = function () {\n  debug('close');\n\n  this._cleanup();\n\n  if (this.sendStop) {\n    this.sendStop();\n    this.sendStop = null;\n  }\n};\n\nmodule.exports = BufferedSender;","map":{"version":3,"sources":["C:/Users/Thivagar/AppData/Roaming/npm/node_modules/expo-cli/node_modules/sockjs-client/lib/transport/lib/buffered-sender.js"],"names":["inherits","require","EventEmitter","debug","process","env","NODE_ENV","BufferedSender","url","sender","call","sendBuffer","prototype","send","message","push","sendStop","sendSchedule","sendScheduleWait","self","tref","clearTimeout","setTimeout","length","payload","join","err","emit","code","close","_cleanup","removeAllListeners","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar inherits = require('inherits')\n  , EventEmitter = require('events').EventEmitter\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:buffered-sender');\n}\n\nfunction BufferedSender(url, sender) {\n  debug(url);\n  EventEmitter.call(this);\n  this.sendBuffer = [];\n  this.sender = sender;\n  this.url = url;\n}\n\ninherits(BufferedSender, EventEmitter);\n\nBufferedSender.prototype.send = function(message) {\n  debug('send', message);\n  this.sendBuffer.push(message);\n  if (!this.sendStop) {\n    this.sendSchedule();\n  }\n};\n\n// For polling transports in a situation when in the message callback,\n// new message is being send. If the sending connection was started\n// before receiving one, it is possible to saturate the network and\n// timeout due to the lack of receiving socket. To avoid that we delay\n// sending messages by some small time, in order to let receiving\n// connection be started beforehand. This is only a halfmeasure and\n// does not fix the big problem, but it does make the tests go more\n// stable on slow networks.\nBufferedSender.prototype.sendScheduleWait = function() {\n  debug('sendScheduleWait');\n  var self = this;\n  var tref;\n  this.sendStop = function() {\n    debug('sendStop');\n    self.sendStop = null;\n    clearTimeout(tref);\n  };\n  tref = setTimeout(function() {\n    debug('timeout');\n    self.sendStop = null;\n    self.sendSchedule();\n  }, 25);\n};\n\nBufferedSender.prototype.sendSchedule = function() {\n  debug('sendSchedule', this.sendBuffer.length);\n  var self = this;\n  if (this.sendBuffer.length > 0) {\n    var payload = '[' + this.sendBuffer.join(',') + ']';\n    this.sendStop = this.sender(this.url, payload, function(err) {\n      self.sendStop = null;\n      if (err) {\n        debug('error', err);\n        self.emit('close', err.code || 1006, 'Sending error: ' + err);\n        self.close();\n      } else {\n        self.sendScheduleWait();\n      }\n    });\n    this.sendBuffer = [];\n  }\n};\n\nBufferedSender.prototype._cleanup = function() {\n  debug('_cleanup');\n  this.removeAllListeners();\n};\n\nBufferedSender.prototype.close = function() {\n  debug('close');\n  this._cleanup();\n  if (this.sendStop) {\n    this.sendStop();\n    this.sendStop = null;\n  }\n};\n\nmodule.exports = BufferedSender;\n"]},"metadata":{},"sourceType":"script"}